{"posts":[{"title":"JVM 内存与垃圾回收（二）","content":"3. 运行时数据区概述及线程 JVM定义了若干程序运行期间使用的数据区，其中一些随虚拟机的创建而创建，随虚拟机推出而销毁；另外一些则随线程的开始结束而创建与销毁。 4. 程序计数器 作用 存储指向下一条指令的地址，即即将执行的指令代码，由执行引擎读取下一条指令。 一块很小的内存空间，运行速度最快的空间 与线程的生命周期保持一致 任何时间一个线程都会只有一个方法在执行=&gt;当前方法。程序计数器会存储当前线程正在执行的方法的JVM指令地址，如果当前线程的当前方法为native方法，则程序计数器为空（undefined） JVM 区域中唯一一个不会OOM的区域 JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，在任一确定的时刻，一个处理器（对于多核处理器来说一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每个线程都需要由一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。 5. 虚拟机栈 5.1 概述 栈是运行时单位，而堆是存储单位 生命周期与线程一致 一个栈帧对应一个java方法 6. 本地方法接口 7. 本地方法栈 8. 堆 9. 方法区 10. 对象的实例化内存布局与访问定位 11. 直接内存 12. 执行引擎 13. StringTable 14. 垃圾回收算法 15. 垃圾回收器 ","link":"https://violet404.github.io/post/aa/"},{"title":"JVM 内存与垃圾回收（一）","content":"1. JVM与Java体系结构 1.1 跨平台性 Java 是一门跨平台的语言，JVM则跨语言的平台，JSR-292 JVM可以运行非Java语言编写的程序 Java平台的多语言混合编程将成主流方向，使用特定领域的语言解决特定领域的问题 1.2 虚拟机 系统虚拟机 对物理计算机的仿真 VMware 程序虚拟机 为执行单个计算机程序而设计 JVM Java技术的核心就是JVM 1.3 JVM 整体结构 HotSpot 1.4 JVM 架构模型 Java 编译器输入的指令流是一种基于栈的指令集架构，除此之外还有一种基于寄存器的指令集架构 这两种指令集架构的区别 基于栈式机构的特点 设计 实现简单，适用于资源受限的系统 避开寄存器的分配难题，使用零地址指令（8位字节对齐）方式分配 指令流中大部分指令是零地址，执行过程依赖与操作数栈，指令集更小（不代表指令少），编译器易实现 不需要硬件支持，移植性好，易实现 跨平台 基于寄存器架构的特点 典型的应用是X86二进制指令集 依赖硬件，移植性差 性能优秀，执行高效 花费更少的指令完成操作 大部分指令以一地址指令、二地址指令和三地址指令为主，16位双字节对齐 2. 类加载子系统 2.1 类加载子系统的作用： 负责从文件系统或者网络中加载class文件，class开头有特定的文件标识 只负责加载class文件，至于能否运行又执行引擎决定 加载的类信息存放在方法区内存空间，除类的信息之外，还包括运行时的常量池的信息， 2.2 类的加载过程 2.2.1 加载 通过一个类的全类名获取定义此类的二进制流 将这个字节流代表的静态存储结构转化位方法去运行时数据结构 在内存中生成一个代表此类的java.lang.Class对象，作为方法区该类的各种数据的访问入口 类的加载器并不需要等到某个类被“首次主动使用”时再加载它 JVM规范允许类加载器在预料将要被使用时就预先加载它，如果在预先加载的过程中遇到.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkError错误) 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。 加载.class文件的方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取 .class文件 将Java源文件动态编译为.class文件 2.2.2 验证 确保class文件符合虚拟机规范，不会危害虚拟机自身安全 文件格式验证、元数据验证、字节码验证、符号引用验证 2.2.3. 准备 为类变量(静态变量)分配内存并设置初始值 不包括常量、实例变量，其中实例变量在类实例化时随对象分配在堆中，类变量在编译阶段就会分配，而在准备阶段时就会显式的初始化（那种不确定的常量的情形待验证！） 2.2.4 解析 将常量池的符号引用转换位直接引用 符号引用：一组符号来描述引用的目标，符号引用的字面量形式在java虚拟机规范的Class文件格式 直接引用：直接指向目标的指针、相对偏移量或者一个间接定位到目标的句柄 解析操作主要针对类、接口、字段、类方法、接口方法等，对应常量池中的CONSTANT_class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等 2.2.5 初始化 初始化就是执行类构造器方法&lt;clinit&gt;()的过程 不需要定义，由javac自动收集类中 所有类变量的赋值动作和静态代码块语句合并而来 &lt;clinit&gt;()对于类或者接口不是必须的，如果一个类没有静态代码块，也没有对变量的赋值操作，编译器将不会为该类生成&lt;clinit&gt;()方法 构造器方法的指令按照语句在源文件出现的顺序执行 静态代码块只能访问定义在代码块之前的类变量；定义在后台的类变量，前面的代码块可以赋值，但是不能访问； &lt;clinit&gt;()不等同与类的构造器&lt;init&gt;()，任何一个类生命以后，至少会存在一个构造器函数（虚拟机视角为&lt;init&gt;()） JVM会在执行子类&lt;clinit&gt;()方法之前执行父类的&lt;clinit&gt;()方法 JVM保证&lt;clinit&gt;()在多线程场景下的同步执行 2.2.6 类的使用 所有的Java虚拟机实现必须在每个类或者接口被Java程序 “首次主动使用” 时才初始化他们。 创建类的实例 访问某个类、接口的静态变量，或对静态变量赋值 调用类的静态方法 反射 初始化一个类的子类 JVM启动时标记为启动类的类 jdk7 开始提供的动态语言支持 java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类如果没有初始化，则初始化 除上述7中情况外，其他使用Java类的方式均为 被动使用，不会导致类的初始化 类被动使用示例 3.1 对于静态字段，只有直接定义该变量的类才会初始化；通过子类引用父类定义的静态变量，指挥触发父类的初始化，而不会导致子类初始化（仅指初始化阶段） 3.2 通过数组定义来引用类，不会触发此类的初始化 对于数组实例来说，其类型是由JVM在运行期间动态生成的，表示为[LSuperClass形式。动态生成的类型（类似于动态代理），其父类型就是Object。 对于数组来说，JavaDoc经常讲构成数组的元素称为Component，实际上就是将数组降低一个维度后的类型。 助记词： anewarray : 表示创建一个引用类型的(如类、接口、数组)数组，并将其引用值压入栈顶 newarray : 表示创建一个指定的原始类型（如int、float、char等）的数组，并将其压入栈顶 3.3 针对在编译阶段就能确定常量值的常量 ,在编译阶段就会存入调用类的常量池，本质上没有直接引用定义常量的类，所以 不会触发定义常量类的初始化 ； 当一个常量的值并非编译期可以确定的，那么其值就不会被放到调用类的常量池中，这时的程序运行时，会导致 主动使用这个常量所在的类 ，显然 会导致这个类被初始化 。 3.4 一个接口初始化时并不要求父接口全部完成初始化，只有真正使用父接口时才会触发初始化 3.4.1. 接口的在编译阶段即可确定常量值的常量使用与类常量情况一致 3.4.2. 通过子接口调用接口父接口编译阶段不能确定值的常量, 父接口会触发初始化，子接口应该不会；即使通过实现类调用，也只会触发定义这个常量所在接口的初始化 3.4.3. 调用实现类的两种常量=&gt;实现类初始化并不会导致所实现的接口完成初始化 2.3 类加载器 这四者为包含关系，不是继承关系 按照虚拟机规范，分为两类: 引导类加载器、自定义类加载器 引导类加载器:BootStrap ClassLoader C/C++ 语言实现 加载Java核心类库，提供JVM自身需要的类 JAVA_HOME/jre/lib/rt.jar JAVA_HOME/jre/lib/resources.jar sun.boot.class.path路径下的内容 不是继承于ClassLoader 加载 扩展类加载器与系统类加载器 处于安全考虑，只加载包名java、javax、sun等开头的类 自定义加载器：Java语言实现 派生于ClassLoader的类加载器 扩展类加载器 父 类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录加载类库、或JDK安装路径下jre/lib/ext目录下加载类库，如果用户创建的jar放在该目录下，也将由扩展类加载器进行加载 应用/程序/系统类加载器 父 类加载器为扩展类加载器 负责加载classpath或者系统属性java.class.path指定路径下的类库 程序中默认的类加载器， 通过ClassLoader#getSystemClassLoader()方法获取该类加载器 用户自定义类加载器 场景 隔离加载类 修改类的加载方式 扩展加载源 防止代码泄露 实现步骤 继承抽象类ClassLoader，1.2之前重写loadClass()方法，1.2之后建议建议将加载逻辑写在findClass()方法 如果没有过于复杂的需求建议直接实现URLClassLoader类，避免自己编写findClass()方法及获取字节码流，使自定义类加载器更加简洁 2.4 ClassLoader 若有一个类加载器能够成功加载某个类，那么这个类加载器成为该类的定义类加载器 任何一个类都有一个定义这个类的ClassLoader的引用 所有能成功返回某个Class对象引用的类加载器（包括定义类加载器）都被称为该类的初始类加载器 对于数组的类加载器来说，通过Class.getClassLoader() 返回的和数组元素的类型类加载器是一样的，如果数组的元素是原生类型的，那么这个数组是没有类加载器的。 获取当前类的类加载器claszz.getClassLoader() 获取当前线程上下文的类加载器Thread.currentThread().getContextClassLoader() 获取系统类加载器ClassLoader.getSystemClassLoader() 获取调用者的类加载器DriverManager.getCallerClassLoader() 自定义类加载器， 下面的代码执行发现自定义的类加载器并未生效，因为CustomizationClassLoader使用系统类加载器作为该类加载器的父 类加载器，而ClassLoaderTest属于classpath下，系统类加载器可以加载classpath下的类，所以CustomizationClassLoader未生效；将ClassLoaderTest.class移动至D:/同时将项目中生成的ClassLoaderTest删除，并把CustomizationClassLoader.filePathPrefix 更新为D:/，重新实行代码，发现先CustomizationClassLoader生效 命名空间 ClassLoaderTest被加载了两次，因为Class对象的hashCode不同， JVM中表示两个类为同一个类的必要条件 类的全限定名相同 加载该类的类加载器（ClassLoader的实例对象）相同 每一个类加载器都有自己的命名空间，命名空间由该类加载器及所有父类加载器所加载类组成 在同一个命名空间下，不会出现全限定名完全相同的两个类 不同的命名空间中，可能会出现全限定名完全相同的两个类 一个类何时结束生命周期，取决于代表它的Class对象合适结束生命周期 Java虚拟机自带的加载器加载的类不会在整个jvm的生命周期中被卸载，而自定义加载器加载的类可以被卸载 -XX:+TraceClassUnloading 需要代码中显示的将ClassLoader及ClassLoader加载的类置空 子加载器所加载的类能够访问到父加载器所加载的类 父加载器所加载的类无法访问到子类加载器所加载的类 2.5 双亲委派机制 原理 如果一个类加载器收到类加载请求，并不会自己先去加载，而是将这个请求委托给父 类加载器执行 如果父 类加载器还存在其父 类加载器，则进一步向上委托，依次请求最终到达顶层启动类加载器 如果父 类加载器可以完成类加载请求，则成功返回，否则将由其子 类加载器尝试加载 优势、为什么 避免重复加载 保护程序安全，防止核心类库被随意篡改 沙箱安全机制 对类加载器的引用 双亲委派机制的破坏 1.2 之前实现自定义类加载器继承ClassLoader重写loadClass方法，JVM进行类加载的时候会调用私有的loadClassInternal()方法，这个方法唯一逻辑就是调用自己的loadClass方法，所以需要在loadClass方法中显示的执行双亲委派逻辑=&gt;1.2之后建议重写findClass方法 JDK JNDI加载厂商代码 OSGi 2.6 JVM自带加载加载路径 ","link":"https://violet404.github.io/post/jvm-1/"},{"title":"游标更新数据","content":" ","link":"https://violet404.github.io/post/you-biao-geng-xin-shu-ju/"},{"title":"@JsonFormatter 时间返回不对","content":"默认返回的时间时区为格林威治时间，Greenwich Time，可以指定时区为东八区，timeZone=&quot;GMT+8&quot; ","link":"https://violet404.github.io/post/jsonformatter-shi-jian-fan-hui-bu-dui/"},{"title":"illegal hex characters in escape(%) pattern","content":"#####原因 在进行URLDecode时，进行decode的字符串含有%（非通过encode产生的） 解决方案 更新数据，将半角%转化为全角的％ update tb set col1 = regexp_replace(col1, chr(37), chr(15711365)) where instr(col1, chr(37)) != 0 ","link":"https://violet404.github.io/post/illegal-hex-characters-in-escape-pattern/"},{"title":"Oracle ResultSet.getDate()/getObject()无法获取时间","content":" 检查驱动Oracle的JDBC的驱动版本，10g版本的驱动会出现上面的情况 解决方式1：可以将驱动版本升级或降级，11或9版本的oracle对应的驱动可以正常获取时间 解决方式2：使用getString()的方式获取，即可获取完整的日志数据 升级驱动版本可能会出现如下异常信息 NoSuchMethodError：oracle.i18n.text.convert.CharacterConvertOGS.getInstance(I)Loracle/i18n/text/convert/CharacterConverter 检查项目中是否同时含有nls_charset与orai18n的jar包，高版本的Oracle驱动与nls_charset冲突（高版本的驱动+orai18n,低版本的驱动+nls_charset） ","link":"https://violet404.github.io/post/oracle-resultsetgetdategetobjectwu-fa-huo-qu-shi-jian/"},{"title":"jQuery 操作多选框checkbox失效","content":"现象如题，改attr赋值为prop方式 ","link":"https://violet404.github.io/post/jquery-cao-zuo-duo-xuan-kuang-checkbox-shi-xiao/"},{"title":"Oracle 行转列","content":" wm-concat oracle12c已废弃该函数,使用方式wm-concat(&lt;合并列&gt;) listagg 11.2 新特性，返回varchar2类型，所以上限4000，如果拼接字符过长，则报错ORA-01489 参数：要合并的列，拼接字符 使用方法： xmlagg 在使用listagg报错ORA-01489字符串超长时，可改为xmlagg方式，返回Clob 使用方法： ","link":"https://violet404.github.io/post/oracle-xing-zhuan-lie/"},{"title":"Uncaught RangeError：Maximum call stack size exceeded","content":" Js函数递归调用次数过多 引入了冲突的Js库，两个库对JS原始对象的相同方法进行了不同的重写 Ajax请求参数错误，检查参数是否存在未定义的变量，且该变量与页面中的某个元素的id值相同 ","link":"https://violet404.github.io/post/uncaught-rangeerrormaximum-call-stack-size-exceeded/"},{"title":"EasyUI 窗口重复加载、窗口元素取值混乱","content":" EasyUI框架window类窗口使用方式 在父页面A弹出子页面B时，子页面B又弹出子页面C的情况，如果C页面对应的div定义在B页面，则C页面取值可能会混乱。EasyUI窗口类组件在调用close方式时，页面上的dom元素并不是直接销毁，而是隐藏。 为避免窗口元素取值错误，定位时建议加上限定范围 ","link":"https://violet404.github.io/post/easyui-chuang-kou-chong-fu-jia-zai-chuang-kou-yuan-su-qu-zhi-hun-luan/"},{"title":"Mybatis 结果集数量与实际不符","content":"问题描述 sql在数据库中执行显示有18条记录，Mapper返回List类型结果集，同时debug显示list.size()为18，但是只能取到8条，遍历导致NPE 排查方向 resultType或者resultMap中的属性影射是否匹配 是否配置有callSetterOnNulls=true 默认情况下，在用map接受返回结果的情况下，mybatis会忽略结果为null的字段，如果对应的所有属性全部为null，则该条记录就会缺失。 可以通过配置callSettersOnNulls=true，达到即使结果为null依然可以获取到. 但是下面两种特殊情况需要注意： 2.1. 查询结果0条记录，会接收到一个所有key对应值为null的map，而不是一个值为null的map。 2.2. 如果查询一个字段，结果为null，此时会返回一个值为null的map，而不是包含key对应值为null的map。 ","link":"https://violet404.github.io/post/mybatis-jie-guo-ji-shu-liang-yu-shi-ji-bu-fu/"},{"title":"Ibatis 批量保存（基于Oracle）","content":" ","link":"https://violet404.github.io/post/ibatis-pi-liang-bao-cun-ji-yu-oracle/"},{"title":"Oracle 替换字符串","content":"函数说明 示例 正则表达式 符号 释义 \\ * 匹配0个或多个 + 匹配1个或多个 ? 匹配0个或1个 | 或运算，所有均可视为单独的子表达式 ^ 默认情况下匹配字符串的结尾，多行模式匹配字符串每一行的行尾 $ 默认情况下匹配字符串的开头，多行模式匹配每一行的行头 . 字符集支持的任意字符，NULL除外 [] 指定匹配列表 () 对表达式分组，视为单个子表达式 {m} 匹配m次 {m,} 匹配至少m次 {m,n} 匹配至少m次，但不超过n次 \\n 反向引用表达式 [::] 指定字符类 字符类 [:XXXX:] 含义 范围 [:space:] 包括换行、空格、tab在内的空白字符 tab 空格 [:blank:] 空格与tab tab 空格 [:alpha:] 字母 a-z A-Z [:alnum:] 字母与数字 a-z A-Z 0-9 [:digit:] 十进制数字 0-9 [:xdigit:] 十六进制数 0-9 a-f A-F [:lower:] 小写字母 a-z [:upper:] 大写字母 A-Z [:cntrl:] 控制字符 ctrl、backspace等 [:punct:] 标点符号 ,.?' 不确定中英文、半角全角 ","link":"https://violet404.github.io/post/oracle-ti-huan-zi-fu-chuan/"},{"title":"Git","content":"修改上一次提交信息 git commit --amend -m &lt;new_message&gt; 修改历史提交信息 git rebase -i &lt;commitId&gt; （commitId，HEAD] 范围，将需要修改的提交 pick 改为 reward，保存即可 CRLF 报错 git config --global core.autocrlf false 远程分支删除后，本地依然能够看到该分支 git remote prune origin origin 为远程仓库名称 比较分支差异 查看dev分支存在而master分支不存在的提交git log dev ^master 查看master比dev多提交了哪些git log dev..master 比较dev与master分支的差异git log dev...master 显示所有差异文件的详细git diff dev master 比较两个分支具体文件的差异git diff dev master &lt;具体文件路径&gt; 显示两分支差异部分git diff dev master --stat 上述情况，显示每个提交所在的分支,例如git log -left-right dev...master 重命名本地分支与远程分支 同一命名空间下无法派生同名项目（以旧项目某一分支派生新项目） 忽略某个文件的提交 保留在版本库当中 从版本库中删除 回退版本 ","link":"https://violet404.github.io/post/git/"},{"title":"MQ消息队列(1)","content":"为什么用？=&gt;使用场景 场景-&gt;技术挑战-&gt;不用与使用的对比 解耦 pub/sub模型，机构、汇率等统一更新处理 异步 提高高延时操作的处理效率 削峰 为什么使用当前的MQ框架？=&gt;选型，Kafka 特性 ActiveMQ RabbitMQ RocketMQ Kafka 单机吞吐量 万级，吞吐量比RocketMQ和Kafka要低了一个数量级 万级，吞吐量比RocketMQ和Kafka要低了一个数量级 10万级，RocketMQ也是可以支撑高吞吐的一种MQ 10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景 topic数量对吞吐量的影响 - - topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降。这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic。 topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源 时效性 ms级 微秒级，这是rabbitmq的一大特点，延迟是最低的 ms级 延迟在ms级以内 可用性 高，基于主从架构实现高可用性 高，基于主从架构实现高可用性 非常高，分布式架构 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 消息可靠性 有较低的概率丢失数据 - 经过参数优化配置，可以做到0丢失 经过参数优化配置，可以做到0丢失 功能支持 MQ领域的功能极其完备 基于erlang开发，所以并发能力很强，性能极其好，延时很低 MQ功能较为完善，还是分布式的，扩展性好 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 优劣势总结 非常成熟，功能强大，在业内大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息。而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本。而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备。而且开源提供的管理界面非常棒，用起来很好用。社区相对比较活跃，几乎每个月都发布几个版本分。在国内一些互联网公司近几年用rabbitmq也比较多一些。但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。 接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控。社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的。 kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展.同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量.而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略.这个特性天然适合大数据实时计算以及日志收集 引入MQ的优缺点 系统可用性降低（高可用） 系统复杂性提高（重复数据、数据丢失、重复消费等） 存在一致性问题（分布式锁） 怎么保证高可用？Kafka ","link":"https://violet404.github.io/post/mq-xiao-xi-dui-lie-1/"},{"title":"分布式锁","content":"锁 jvm层面的枷锁，单机版 分布式微服务拆分后，为避免冲突与数据故障而加入的一种锁 分布式锁 实现方案 mysql zookeeper redis 一般常用redis redis --&gt; redlock ===&gt;redisson lock unlock 请求 --》nginx 写入排队 redis service2 ","link":"https://violet404.github.io/post/fen-bu-shi-suo/"},{"title":"Redis常用类型与应用场景","content":"查看redis版本 1.redis-server -v（linux） 2.info （进入redis后） redis命令不区分大小写，key区分大小写 redis 帮助命令 help @&lt;类型名词&gt; 5大数据类型 string 常用 set key value get key 同时设置、获取多个键值 mset key value [key value ...] mget key [key ...] 数值增减 递增 incr key 增加指定的整数 incrby key increment 递减 decr key 递减指定 decrby key decrement 获取字符串长度 strlen key 分布式锁 setnx key value 如果不存在则创建 set key value [EX seconds] [PX milliseconds] [NX | XX] EX 指定秒过期 PX 指定毫秒过期 NX 当key不存在时创建key，效果等价于setnx XX 当key存在时覆盖key 应用场景 商品、文章的点踩incr、decr list 有序有重复，双向链表 左侧添加元素 lpush key value [value ...] rpush key value [value...] 查看列表 lrange key start stop 获取列表元素个数 llen key 应用场景 文章订阅公众号 hash 对应java中的Map&lt;string, Map&lt;Object, Object&gt;&gt; 一次设置一个字段 hset key field value 一次获取一个字段 hset key field 一次设置多个字段 hmset key field value [field value ...] 一次获取获取多个字段值 hmset key field [field ...] 获取所有字段值 hgetall key 获取某个key内的全部数量 hlen 删除一个 key hdel 属性自增 hincrby 同string 应用场景 购物车（中小厂）、订餐等汇集场景 set 无序无重复 添加 sadd key member [member] 删除 srem key member [member] 获取所有元素 smembers key 判断元素是否在集合中 sismember key member 获取元素个数 scard key 从集合中随机弹出一个元素，不删除 srandmember key [数字] 从集合随机弹出，并删除 spop key [数字] 集合运算 差集A-B 属于A但不属于B sdiff key [key ...] 交集 sinter key [key ...] 并集 sunion key [key ...] 应用场景 抽奖小程序 点赞 共同关注的人、共同的爱好 可能认识的人 zset（sorted set） 向有序集合中添加一个元素与其分数 zadd key score member [score member ...] 按照分数从小到大返回索引区分的元素 zrange key start stop [withscores] 获取元素的分数 zscore key member 删除元素 zrem key member [member ...] 获取指定分数范围的元素 zrangebyscore key min max [withscore][limit offset count] 增加某个元素的分数 zincrby key increment member 获取元素的数量 zcard key 获取指定分数范围内元素的数量 zcount key min max 按照排序删除元素zremrangebyrank key start stop 获取元素排名 zrank key member /zrevrank key member 场景 排行榜 bitmap 位图 HyperLogLogs GEO 地理信息 Stream ","link":"https://violet404.github.io/post/redis/"}]}